#
# Copyright (c) Sebastian Kucharczyk <kuchen@kekse.biz>
# https://kekse.biz/
#
# ORIGINAL VERSION!!
# DO NOT USE!
# It's only a hint for the future design of 'baseutils[.sh]'!
#

export SHA="sha512sum"
export PREFIX=" >> "

toText()
{
	len="${#1}"

	if [[ $len -le 3 ]]; then
		if [[ $len -eq 0 ]]; then
			echo "0"
		else
			echo "$1"
		fi

		return
	fi

	result=""

	for (( i=$(($len-1)),j=0; i >= 0; --i,++j )); do
		result="${1:$i:1}${result}"

		if [[ $j -eq 2 && $i -gt 0 ]]; then
			result=".${result}"
			j=-1
		fi
	done

	echo "$result"
}

now()
{
	echo "$((`date +'%s%N'`/1000000))"
}

writeColorString()
{
	stream=0
	res=""

	case "$1" in
		"info") stream=1
			res="\033[38;2;"
			for i in $infoColor; do
				res="${res}$i;"
			done
			res="${res::-1}m"
			;;
		"warn") stream=2
			res="\033[38;2;"
			for i in $warnColor; do
				res="${res}$i;"
			done
			res="${res::-1}m"
			;;
		"error") stream=2
			res="\033[38;2;"
			for i in $errorColor; do
				res="${res}$i;"
			done
			res="${res::-1}m"
			;;
		"debug") stream=1
			res="\033[38;2;"
			for i in $debugColor; do
				res="${res}$i;"
			done
			res="${res::-1}m"
			;;
		"log")   stream=1
			res=""
			;;
		*)
			echo "ERROR (invalid stream '$1')" >&2;
			return 1
			;;
	esac
	
	if [[ "$1" = "log" ]]; then
		res="${res}${PREFIX}$2"
	else
		res="${res}${PREFIX}$2\033[0m"
	fi
	
	case $stream in
		1) echo -e "$res";;
		2) echo -e "$res" >&2;;
	esac
}

log()
{
	writeColorString "log" "$*"
}

infoColor="173 234 68"

info()
{
	writeColorString "info" "$*"
}

warnColor="255 153 20"

warn()
{
	writeColorString "warn" "$*"
}

errorColor="242 67 51"

error()
{
	writeColorString "error" "$*"
}

debugColor="68 172 234"

debug()
{
	writeColorString "debug" "$*"
}

#extract()
#{
#	# cat lib.js | head -n530 | tail -n$((530-333)) > p
#	#TODO# '-d|--delete' (removes extracted part in the source file (if any!))
#
#	if [ $# -lt 1 ]; then
#		echo "Syntax: extract <from> [ <to> [ <path> ] ]" >&2
#		return 1
#	fi
#
#	_from=$1
#	_to=$2
#	_path=$3
#
#	if [ -z "$_to" ]; then
#		_to=-1
#	fi
#
#	if [ -z "$_path" ]; then
#		_path="-"
#	fi
#
#	_data="`cat \"$_path\"`"
#	_total=`echo "$_data" | wc -l`
#
#	if [ $_from -lt 0 ]; then
#		let _from=$_total+$_from+1
#	fi
#
#	if [ $_to -lt 1 ]; then
#		let _to=$_total+$_to+1
#	fi
#
#	if [ $_from -gt $_to ]; then
#		echo "WARNING: <from> must be smaller than or equal to <to>" >&2
#		return 2
#	fi
#
#	if [ $_from -lt 1 ]; then
#		_from=1
#	fi
#
#	if [ $_to -gt $_total ]; then
#		_to=$_total
#	fi
#
#	echo "`echo \"$_data\" | head -n$_to | tail -n$(($_to-$_from+1))`"
#}

insert()
{
	echo TODO >&2
}

#list()
#{
#	_sleep=1
#
#	while [ 1 ]; do
#		clear
#		ls -al --color=auto $*
#		sleep $_sleep
#	done
#}

width()
{
	if [ -z "$COLUMNS" ]; then
		tput cols
	else
		echo $COLUMNS
	fi
}

height()
{
	if [ -z "$LINES" ]; then
		tput lines
	else
		echo $LINES
	fi
}

lastChars()
{
	if [ $# -lt 2 ]; then
		echo -e "Syntax: lastChars <length> <string>" >&2
		return 1
	fi

	length="$1"
	shift
	string="$*"

	echo -e "${string:${#string}-$length}"
}

#extname()
#{
#	if [ $# -eq 0 ]; then
#		echo -e "Syntax: extname <path> [ <count> ]" >&2
#		return 1
#	fi
#
#	_dir="`dirname \"$1\"`"
#	_path="`basename \"$1\"`"
#
#	[ "`echo $_path | count .`" = "0" ] && return
#
#	let _count=1
#	[ $# -ge 2 ] && let _count=$2
#
#	if [ $_count -eq 0 ]; then
#		echo -e ".${_path#*.}"
#		return
#	fi
#	# TODO # reverse the extensions, if [ $_count -lt 0 ]; ...
#
#	ext=""
#
#	IFS=" "
#	for i in `seq -s ' ' 1 $_count`; do
#		_ext="${_path##*.}"
#		[ "$_ext" = "${_path%%.*}" ] && break;
#		ext="$_ext.$ext"
#		_temp="$_path"
#		_path="${_path%.*}"
#		[ "$_temp" = "$_path" ] && break;
#	done
#	ext=".${ext::-1}"
#
#	echo -e "$ext"
#}

#basename()
#{
#	base="${*##*/}"
#	# TODO: 2nd 'extension' parameter
#	echo -e "$base"
#}

firstname()
{
	# "..//./ab  cd/e fg// /" => "ab  cd" ;-)

	# BUG: DOT FILES are not yet supported! still TODO! ... :-/

	p="$*"

	while [ "${p:0:1}" = "." -o "${p:0:1}" = "/" ]; do
		p="${p:1}"
	done

	echo "${p%%/*}"
}

abs()
{
	if [ $# -eq 0 ]; then
		echo "Syntax: abs <number> [ ... ]" >&2
		return 1
	fi

	_result=""

	for _nr in $*; do
		if [ "${_nr:0:1}" = "-" ]; then
			_result="$_result ${_nr:1}"
		else
			_result="$_result $_nr"
		fi
	done

	echo "${_result:1}"
}

pad()
{
	if [ $# -lt 2 ]; then
		echo "Syntax: pad <text> <offset> [ <string> ]" >&2
		return 1
	fi

	_string="$1"
	_offset=$2
	_padStr="$3"

	_result=""
	_abs=`abs $_offset`

	if [ -z "$_padStr" ]; then
		_padStr=" "
	fi

	if [ ${#_string} -eq $_abs ]; then
		_result="$_string"
	elif [ ${#_string} -gt $_abs ]; then
		let _diff=$_abs-${#_string}
		if [ "${_offset:0:1}" = "-" ]; then
			_result="${_string:$_diff:$_abs}"
		else
			_result="${_string:0:$_abs}"
		fi
	else
		let _j=0
		_result="$_string"
		while [ ${#_result} -lt $_abs ]; do
			if [ "${_offset:0:1}" = "-" ]; then
				_result="${_padStr:$_j:1}$_result"
			else
				_result="$_result${_padStr:$_j:1}"
			fi
			_j=$((($_j+1)%${#_padStr}))
		done
	fi

	echo "$_result"
}

#keep()
#{
#	_set=0
#	_unset=0
#
#	IFS=$'\n'
#
#	for _d in `find ./ -type d`; do
#		echo -en "$*" > "$_d/.keep"
#		let _set=$_set+1
#	done
#
#	for _g in `find ./ -type d -name .git`; do
#		for _k in `find $_g/ -type f -name .keep`; do
#			rm "$_k"
#			let _unset=$_unset+1
#		done
#	done
#
#	echo "FINISHED! ($_set) '.keep's set, ($_unset) unset again.."
#	echo " ... so there are ($(($_set-$_unset))) .keep files left! ;-)"
#}

unkeep()
{
	IFS=$'\n'

	removed=0

	for f in `find ./ -type f -name .keep`; do
		rm "$f"
		let removed=$removed+1
	done

	echo -e "FINISHED! ($removed) '.keep' files removed. :-)"
}

indent()
{
	# TODO!! #

	syntax()
	{
		echo "Syntax: indent (..)" >&2
		echo >&2
		echo "Examples:" >&2
		echo -e " > indent -t2\t\t# Removes two tabs in every line" >&2
		echo -e " > indent +t1 -s8\t# Convert (8) spaces to (1) tab" >&2
		echo -e " > indent *s2\t\t# Multiplies spaces with (2) (doubled)" >&2
		echo -e " > indent +t2\t\t# Adds (2) tabs at the line beginning" >&2
		echo -e " > indent -s +t1\t# Removes ALL spaces and adds (1) tab" >&2
		echo >&2
	}

	if [ $# -lt 1 ]; then
		syntax
		return 1
	fi

	echo TODO >&2
	return 255


#	_sign="${_amount:0:1}"
#
#	if [ "$_sign" = "-" -o "$_sign" = "+" ]; then
#		_amount="${_amount:1}"
#	else
#		_sign="+"
#	fi
#
#	_lines="0"
#	_result=""
#	_data="`cat -- \"$_file\"`"
#
#	while read _line; do
#		let _lines=$_lines+1
#	done <<< $_data
#
#	echo -e "\n\t($_lines) successfully indented by ($_amount)." >&2
}

unique()
{
	# make items `uniq` w/ counting them (prefix) and sorting by numbers
	echo TODO >&2
	return 255
}

#prefix()
#{
#	syntax()
#	{
#		echo "Syntax: prefix <prefix> [ <path> ]" >&2
#	}
#
#	if [ $# -lt 1 ]; then
#		syntax
#		return 1
#	fi
#
#	_prefix="$1"
#	_path="$2"
#
#	if [ -z "$_prefix" ]; then
#		syntax
#		return 2
#	fi
#
#	if [ -z "$_path" ]; then
#		while read _line; do
#			echo "${_prefix}${_line}"
#		done
#	else
#		if [ ! -f "$_path" ]; then
#			echo "File not found" >&2
#			return 3
#		fi
#
#		while read _line; do
#			echo "${_prefix}${_line}"
#		done < $_path
#	fi
#}

removeleft()
{
	if [ $# -eq 0 ]; then
		echo "Syntax: removeleft <length> [ <input> [ <output> ] ]"
		return 1
	fi

	# TODO # check if numeric input.. (everywhere else in this file, too, please! ;-)
	length="$1"

	input="-"
	output="-"

	if [ $# -ge 2 ]; then
		input="$2"
	fi

	if [ $# -ge 3 ]; then
		output="$3"
	fi

	result=""
	count=0

	if [ "$input" = "-" ]; then
		while read _line; do
			result="$result
${_line:$length}"
			let count=$count+1
		done
	else
		while read _line; do
			result="$result
${_line:$length}"
			let count=$count+1
		done < $input
	fi

	result="${result:1}"

	if [ "$output" = "-" ]; then
		echo "$result"
	else
		echo "$result" > "$output"
		echo "$count lines processed.."
	fi
}

repeat()
{
	DELAY=1

	if [ $# -eq 0 ]; then
		echo "Syntax: repeat \'<cmd>\' [ ... ]" >&2
		return 1
	fi

	while [ 1 ]; do
		clear

		for cmd in "$@"; do
			eval $cmd
		done

		sleep $DELAY
	done
}

substr()
{
	if [ $# -ne 3 ]; then
		echo "Syntax: substr <text> <start> [ <length> ]" >&2
		return 1
	fi

	# TODO #
}

longest()
{
	echo TODO >&2
	return 255

	# TODO # find longest string(/line/word/..) to scale "pad" the best..
}

yesno()
{
	# TODO # bit buggy..
	# .. on pressing just <Enter> @ `read`

	prompt="$*"

	if [ -z "$prompt" ]; then
		prompt=" < Yes / No > "
	fi

	query()
	{
		read -p "$prompt" _answer

		case "`lowercase $_answer`" in
			y|ye|yes)
				echo -n 1
				return 1
				;;
			n|no)
				echo -n 0
				return 0
				;;
		esac

		echo -n -1
		return -1
	}

	while [ 1 ]; do
		_select=`query`
		if [ $_select -ge 0 ]; then
			echo -n $_select
			return $_select
		fi
	done
}

#replace()
#{
#	echo TODO >&2
#	return 255
#}

menu()
{
	echo TODO >&2
	return 255

	# TODO #

	# (give items w/ values, otherwise only num. indices.. but!)..
	# [lists/tables can also be encoded in (a) file(s)..]!

	if [ $# -eq 0 ]; then
		echo "Syntax: menu <path> | <item> [ ... ]" >&2
		return 1
	fi
}

#uppercase()
#{
#	_path="$1"
#	_data="$*"
#
#	if [ $# -eq 0 ]; then
#		_path="-"
#		_data="`cat \"$_path\"`"
#	elif [ $# -eq 1 ]; then
#		if [ -r "$_path" ]; then
#			_data="`cat \"$_path\"`"
#		else
#			_data="$_path"
#			_path=""
#		fi
#	else
#		_path=""
#	fi
#
#	echo -n "`echo -n \"$_data\" | tr "a-z" "A-Z"`"
#	
#	if [ -z "$_path" -o "$_path" = "-" ]; then
#		echo
#	fi
#}

#lowercase()
#{
#	_path="$1"
#	_data="$*"
#
#	if [ $# -eq 0 ]; then
#		_path="-"
#		_data="`cat \"$_path\"`"
#	elif [ $# -eq 1 ]; then
#		if [ -r "$_path" ]; then
#			_data="`cat \"$_path\"`"
#		else
#			_data="$_path"
#			_path=""
#		fi
#	else
#		_path=""
#	fi
#
#	echo -n "`echo -n \"$_data\" | tr "A-Z" "a-z"`"
#
#	if [ -z "$_path" -o "$_path" = "-" ]; then
#		echo
#	fi
#}

#randomcase()
#{
#	echo TODO >&2
#	return 255
#}

#random()
#{
#	SHUF="`which shuf 2>/dev/null`"
#
#	if [ -z "$SHUF" ]; then
#		echo "Command \`shuf\` is not available!" >&2
#		return 1
#	fi
#
#	PRECISION=16
#
#	if [ $# -eq 1 ]; then
#		PRECISION=$1
#	fi
#
#	result="0."
#
#	for _i in `seq 1 $PRECISION`; do
#		result="$result$($SHUF --random-source=/dev/urandom --head-count=1 --input-range=0-9)"
#	done
#
#	echo "$result"
#}

#randoms()
#{
#	SHUF="`which shuf 2>/dev/null`"
#
#	if [ -z "$SHUF" ]; then
#		echo "Command \`shuf\` is not available!" >&2
#		return 1
#	fi
#
#	if [ $# -lt 2 ]; then
#		echo "Syntax: randoms <length> <max> [ <min> [ <separator> ] ]" >&2
#		return 2
#	fi
#
#	LEN=$1
#	MAX=$2
#	MIN=0
#	SEP=$'\n'
#
#	if [ $# -ge 3 ]; then
#		MIN=$3
#
#		if [ $# -gt 3 ]; then
#			SEP="$4"
#		fi
#	fi
#
#	result=""
#	
#	IFS=$'\n'
#	for _i in `seq 1 $LEN`; do
#		result="${result}${SEP}$($SHUF --random-source=/dev/urandom --head-count=1 --input-range=$MIN-$MAX)"
#	done
#
#	result="${result:${#SEP}}"
#
#	echo "$result"
#}

randomBits()
{
	if [ $# -lt 1 ]; then
		echo "Syntax: randomBits <length> [ <separator> ]" >&2
		return 1
	fi

	LEN=$1
	MAX=1
	MIN=0
	SEP=$'\n'

	if [ $# -ge 2 ]; then
		SEP="$2"
	fi

	randoms $LEN $MAX $MIN "$SEP"
}

randomHexa()
{
	if [ $# -lt 1 ]; then
		echo "Syntax: randomHexa <length> [ <separator> ]" >&2
		return 1
	fi

	LEN=$1
	MAX=15
	MIN=0
	SEP=$'\n'

	if [ $# -ge 2 ]; then
		SEP="$2"
	fi

	result=""

	IFS=$'\n'
	for _i in `seq 1 $LEN`; do
		rnd=`randoms 1 15`
		case $rnd in
			0|1|2|3|4|5|6|7|8|9)
				result="$result$SEP$rnd";;
			10)
				result="$result${SEP}a";;
			11)
				result="$result${SEP}b";;
			12)
				result="$result${SEP}c";;
			13)
				result="$result${SEP}d";;
			14)
				result="$result${SEP}e";;
			15)
				result="$result${SEP}f";;
		esac
	done

	result="${result:${#SEP}}"

	echo "$result"
}

randomOcta()
{
	if [ $# -lt 1 ]; then
		echo "Syntax: randomOcta <length> [ <separator> ]" >&2
		return 1
	fi

	LEN=$1
	MAX=7
	MIN=0
	SEP=$'\n'

	if [ $# -ge 2 ]; then
		SEP="$2"
	fi

	randoms $LEN $MAX $MIN "$SEP"
}

#eol()
#{
#	_nl=1
#
#	if [ $# -gt 0 ]; then
#		_nl=$1
#	fi
#
#	while [ $_nl -gt 0 ]; do
#		echo
#		let _nl=$_nl-1
#	done
#}

# TODO # i've already implemented better versions. see 'kernel.js'! ;-)
#line()
#{
#	# see `export LINE` ('./env.sh')
#
#	_default="-"
#	_pad="$*"
#
#	if [ -z "$_pad" ]; then
#		_pad="$LINE"
#		if [ -z "$_pad" ]; then
#			_pad="$_default"
#		fi
#	fi
#
#	_width=`tput cols`
#	_data=""
#	_ptr=0
#
#	for _i in `seq 1 $_width`; do
#		_data="${_data}${_pad:$_ptr:1}"
#		_ptr=$((($_ptr+1)%${#_pad}))
#	done
#
#	echo "$_data"
#}

#left()
#{
#	echo TODO >&2
#	return 255
#
#	# see `export LINE` ('./env.sh')
#
#	_default="-~"
#
#	_text="$1"
#	_pad="$2"
#
#	if [ -z "$_pad" ]; then
#		_pad="$LINE"
#		if [ -z "$_pad" ]; then
#			_pad="$_default"
#		fi
#	fi
#
#	_width=`tput cols`
#	_data="$text"
#	_ptr=0
#
#	for _i in `seq $((${#_data}+1)) $_width`; do
#		_data="${_data}${_pad:$_ptr:1}"
#		_ptr=$((($_ptr+1)%${#_pad}))
#	done
#
#	echo "$_data"
#}

#center()
#{
#	# see `export LINE` ('./env.sh')
#
#	_default="-~"
#
#	_text="$1"
#	_pad="$2"
#
#	if [ -z "$_pad" ]; then
#		_pad="$LINE"
#		if [ -z "$_pad" ]; then
#			_pad="$_default"
#		fi
#	fi
#
#	_width=`tput cols`
#	_data=""
#	_ptr=0
#
#	_centerPos=$((($_width-${#_text})/2)) # 'round'ed selbst..
#
#	for _i in `seq 1 $_centerPos`; do
#		_data="${_data}${_pad:$_ptr:1}"
#		_ptr=$((($_ptr+1)%${#_pad}))
#	done
#
#	_data="$_data$_text"
#	_from=$(($_centerPos+${#_text}+1))
#
#	for _i in `seq $_from $_width`; do
#		_data="${_data}${_pad:$_ptr:1}"
#		_ptr=$((($_ptr+1)%${#_pad}))
#	done
#
#	echo "$_data"
#}

#right()
#{
#	echo TODO >&2
#	return 255
#
#	# see `export LINE` ('./env.sh')
#
#	_default="-~"
#
#	_text="$1"
#	_pad="$2"
#
#	if [ -z "$_pad" ]; then
#		_pad="$LINE"
#		if [ -z "$_pad" ]; then
#			_pad="$_default"
#		fi
#	fi
#
#	_width=`tput cols`
#	_data=""
#	_ptr=0
#
#	_endPos=$(($_width-${#_text}))
#
#	for _i in `seq 1 $_endPos`; do
#		_data="${_data}${_pad:$_ptr:1}"
#		_ptr=$((($_ptr+1)%${#_pad}))
#	done
#
#	data="$_data$_text"
#	echo "$_data"
#}

#round()
#{
#	if [ $# -eq 0 ]; then
#		echo "Syntax: round <float> [ <precision> ]" >&2
#		return 1
#	fi
#
#	_nr=$1
#	_prec=0
#
#	if [ $# -gt 1 ]; then
#		_prec=$2
#	fi
#
#	printf "%.${_prec}f" $_nr
#}

mkpasswd()
{
	if [ $# -lt 1 ]; then
		echo "Syntax: mkpasswd <user> [ <password> ]" >&2
		return 1
	fi

	_user="$1"
	_pass="$2"

	while [ -z "$_pass" ]; do
		echo
		read -sp "New password: " _pass
	done
	echo
	echo "$_user:`openssl passwd -crypt \"$_pass\"`"
}

isroot()
{
	if [ "`id -u`" -eq 0 ]; then
		echo 1
	else
		echo 0
	fi
}

hasroot()
{
	if [ "`id -g`" -eq 0 ]; then
		echo 1
	else
		echo 0
	fi
}

hide()
{
	if [ $# -eq 0 ]; then
		echo "Syntax: hide <path> [ ... ]" >&2
		return 1
	fi

	for path in "$@"; do
		file="`basename \"$path\"`"
		dir="`dirname \"$path\"`"

		git mv "$dir/$file" "$dir/.$file" 2>/dev/null
		mv -v "$dir/$file" "$dir/.$file" 2>/dev/null
	done
}

show()
{
	if [ $# -eq 0 ]; then
		echo "Syntax: show <path> [ ... ]" >&2
		return 1
	fi

	for path in "$@"; do
		file="`basename \"$path\"`"
		dir="`dirname \"$path\"`"
		new="${file:1}"

		git mv "$dir/$file" "$dir/$new" 2>/dev/null
		mv -v "$dir/$file" "$dir/$new" 2>/dev/null
	done
}

exists()
{
	if [ $# -eq 0 ]; then
		echo "Syntax: exists <file>" >&2
		return 1
	fi

	if [ -z "`which \"$*\" 2>/dev/null`" ]; then
		echo "no"
	else
		echo "yes"
	fi
}

profile()
{
	dir="/etc/profile.d/kekse"

	if [ $# -gt 0 ]; then
		if [ -d "$1" ]; then
			dir="$1"
			echo "Using directory '$dir'.."
		else
			echo "Directory '$dir' doesn't exist!" >&2
			return 1
		fi
	fi

	echo
	count=0
	none=0
	errors=0

	for sh in $dir/*.sh ; do
		if [ -r "$sh" ]; then
			let count=$count+1
			err=""
			. "$sh" >/dev/null 2>&1
			if [ $? -ne 0 ]; then
				let errors=$errors+1
				err="!"
			fi
			printf "$err\t[%2d] '%s'\n" $count $sh
		else
			let none=$none+1
		fi
	done
	unset sh

	echo -e "\nSource'd $count files, $none ignored, $errors errors."
}

every()
{
	echo TODO >&2

	# show every n'th line .. or hide every n'th line ... at least this! :-)
}

cpp()
{
	if [ $# -eq 0 ]; then
		echo -e "Usage: cpp <name(s)> [ <namespace> ]" >&2
		return 1
	fi

	rest="$1"
	namespace="$2"
	count=0
	path="./"
	
	while [ -n "$rest" ]; do
		let count=$count+1

		elem="${rest%%.*}"
		length="${#elem}"
		rest="${rest:$length+1}"

		path="$path/$elem"

		if [ -z "$rest" ]; then
			base="${path##*/}"

			if [ -s "$path.h" ]; then
				mv "$path.h" "$path.h.ORIG"
				mv "$path.cpp" "$path.cpp.ORIG" 2>/dev/null
				[ -f "$path.cpp.ORIG" ] || touch "$path.cpp.ORIG"
			fi
			if [ -s "$path.cpp" ]; then
				mv "$path.cpp" "$path.cpp.ORIG"
				mv "$path.h" "$path.h.ORIG"
				[ -f "$path.h.ORIG" ] || touch "$path.h.ORIG"
			fi

			echo -e "#include \"$base.h\"" >"$path.cpp"

			if [ -n "$namespace" ]; then
				echo -e "\nusing namespace $namespace;\n" >>"$path.cpp"
				echo -en "namespace $namespace\n{\n\t" >>"$path.h"
			fi

			echo -e "class $base" >>"$path.h"

			[ -n "$namespace" ] && echo -en "\t" >>"$path.h"

			echo -e "{" >>"$path.h"

			[ -n "$namespace" ] && echo -en "\t" >>"$path.h"

			echo -e "};" >>"$path.h"

			[ -n "$namespace" ] && echo -e "}" >>"$path.h"

		else
			mkdir "$path/" 2>/dev/null
		fi
	done

	echo -e " >> Created '$1' ('$path..')! :-)"
}

oldjs()
{
	if [ $# -eq 0 ]; then
		echo -e "Usage: js <name(s)>" >&2
		return 1
	fi

	extends=""
	[ $# -gt 1 ] && extends="$2"

	rest="$1"
	count=0
	path="./"

	while [ -n "$rest" ]; do
		let count=$count+1

		elem="${rest%%.*}"
		length="${#elem}"
		rest="${rest:$length+1}"

		path="$path/$elem"

		if [ -z "$rest" ]; then
			base="${path##*/}"

			[ -s "$path.js" ] && mv "$path.js" "$path.js.ORIG"

			[ -n "$shebang" ] && echo -e "#!$shebang\n" >>"$path.js"

			echo -en "class $base"

			if [ -n "$extends" ]; then
				echo -e " extends $extends" >>"$path.js"
			else
				echo >>"$path.js"
			fi

			echo -e "\n{\n\tconstructor()\n\t{\n\t\t//super.apply(this, arguments);\
				\n\t}\n}\n\n//\nmodule.exports = $base;" >>"$path.js"
		else
			mkdir "$path/" 2>/dev/null
		fi
	done

	echo -e " >> Created class '$1' (extends '$extends') @ '$path')! :-)"
}

#sequence()
#{
#	if [ $# -eq 0 ]; then
#		echo "Usage: count <to> [ <from> [ <step> [ <sep> ] ] ]" >&2
#		return 1
#	fi

#	to="$1"
#	from="$2"
#	step="$3"
#	sep="$4"

#	[ -z "$from" ] && from="1"
#	[ -z "$step" ] && step="1"
#	[ -z "$sep" ] && sep=$'\n'
#
#	seq --separator="$sep" $from $step $to
#}

#search()
#{
#	find ./ -iname "*$**" -o -iname ".*$**"
#}

up()
{
	levels="$1"
	[ -z "$levels" ] && levels=1

	for i in `seq 1 $levels`; do
		cd ../
	done

	echo "You are $levels levels higher now."
}

hashes()
{
	[ -z "$SHA" ] && SHA="sha512sum"

	result=""

	for item in ./*; do
		result="$result
$($SHA "$item")"
	done

	result="$(echo -e "$result" | sort)"

	echo -e "$result"
}

wrap()
{
	# TODO #
	#
	# i should automatically remove files with the same contents (using 'sha512sum' e.g.)!
	# or maybe another script for this? maybe even javascript in lib.js??
	# .. yes! ;-D
	#

	if [ $# -eq 0 ]; then
		echo -e "Syntax: $0 <target directory> <search phrase>" >&2
		return 1
	fi

	target="$1"

	if [ ! -d "$target" ]; then
		echo -e "Please specify a valid target directory (as your first argument)!" >&2
		echo -e "The rest of your cmdline can be a phrase to search for (from your CWD)." >&2
		return 2
	fi

	shift
	find="$*"

	count=0
	IFS=$'\n'
	for item in $(find ./ -iname "$*"); do
		let count=$count+1
		printf "[%4s] '$item'\n" $count
		cp -rf "$item" "$target/$count"
	done

	cd "$target" && ls -ahl
}

